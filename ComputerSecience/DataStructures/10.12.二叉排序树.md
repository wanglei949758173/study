# 二叉排序树

## 基本介绍

**二叉排序树**：BST: (Binary Sort(Search) Tree), 对于二叉排序树的**任何一个非叶子节点**，要求**左子节点的值比当前节点的值小**，**右子节点的值比当前节点的值大**。

**特别说明**：如果有相同的值，可以将该节点放在左子节点或右子节点

比如针对数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：

![image-20200723211620456](10.12.二叉排序树.assets/image-20200723211620456.png)

## 添加节点

```java
public class BinarySortTree {
	// 根节点
	private Node root;

	public BinarySortTree(Node root) {
		this.root = root;
	}

	// 添加节点
	public void add(Node node) {
		if (this.root == null) {
			this.root = node;
		} else {
			this.root.add(node);
		}
	}
}

public class Node {
	// 节点的值
	public int value;

	// 左子节点
	public Node left;

	// 右子节点
	public Node right;

	public Node(int value) {
		super();
		this.value = value;
	}

	@Override
	public String toString() {
		return "Node [value=" + value + "]";
	}

	// 添加节点
	public void add(Node node) {
		// 小于,往左放
		if (node.value < this.value) {
			if (this.left == null) {
				this.left = node;
			} else {
				this.left.add(node);
			}
		} else {
			// 大于等于,往右放
			if (this.right == null) {
				this.right = node;
			} else {
				this.right.add(node);
			}
		}
	}
}
```

## 中序遍历

```java
public class BinarySortTree {
	// 根节点
	private Node root;

	public BinarySortTree(Node root) {
		this.root = root;
	}

	// 中序遍历
	public void infixOrder() {
		if (this.root == null) {
			System.out.println("二叉排序树为空");
		} else {
			this.root.infixOrder();
		}
	}
}

public class Node {
	// 中序遍历
	public void infixOrder() {
		if (this.left != null) {
			this.left.infixOrder();
		}

		System.out.println(this);

		if (this.right != null) {
			this.right.infixOrder();
		}
	}
}
```

