# CircularQueue(循环队列)
使用取模的方法。

## 思路分析
`head`指向队列的头，`tail`指向队列的尾
### 队列何时为空
`head > tail`
当队列头`head`等于队列尾`tail`时，代表队列只剩下最后一个元素，因此当`head > tail`时对列为空。

---

### 队列何时为满
`(tail - head) + 1 == queueSize`
因为`(tail - head) + 1`等于数组中真正存在的元素的个数，因此当`(tail - head) + 1 == queueSize`时代表队列已满

---

### 入队思路
1. 判断队列是否已满
2. `tail++`
3. 将元素入队(`data[this.tail % queueSize] = element`)

---

### 出队思路
1. 判断队列是否已空
2. 取出对首元素(`int headElement = data[this.head % queueSize]`)
3. `this.head++`
4. 返回`headElement`

---

## 代码实现
### 属性和构造函数
```java
class CircularQueue {
	// 队列头,指向队首元素
	private int head;

	// 队列尾,指向最后一个元素
	private int tail;

	// 队列大小
	private int queueSize;

	// 数据
	private int[] data;

	/**
	 * 构造函数
	 *
	 * @param queueSize
	 *            队列大小
	 */
	public CircularQueue(int queueSize) {
		this.queueSize = queueSize;
		data = new int[queueSize];
		this.head = 0;
		this.tail = -1;
	}
}
```

### 入队
```java
public boolean offer(int element) {
  if (isFull()) {
    return false;
  } else {
    this.tail++;
    data[this.tail % this.queueSize] = element;
    return true;
  }
}

public boolean isFull() {
  return (this.tail - this.head) + 1 == this.queueSize;
}
```

### 出队
```java
public int poll() {
  if (isEmpty()) {
    return -1;
  } else {
    int returnNumber = data[this.head % this.queueSize];
    this.head++;
    return returnNumber;
  }
}

public boolean isEmpty() {
  return this.head > this.tail;
}
```