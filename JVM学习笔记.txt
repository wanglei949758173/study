类加载
	在JAVA代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的
	加载：查找并加载类的二进制数据
	连接：
		-验证：确保被加载的类的正确性
		-准备：为类的静态变量分配内存，并将其初始化为默认值
			class Test {
				public static int a = 1;
			}
			在准备阶段会给a赋值为0
		-解析：把类中的符号引用转换为直接引用
	初始化：为类的静态变量赋予正确的初始值
		class Test {
			public static int a = 1;
		}
		在初始化阶段会给a赋值为1
		
	Java程序对类的使用方式分为两种：
		-主动使用
		-被动使用
		
		所有的Java虚拟机实现必须在每个类或接口被Java程序”首次主动使用“时才初始化他们
			主动使用(7种)
				-创建类的实例
				-访问某个类或接口的静态变量，或者对该静态变量赋值 getstatic putstatic
				-调用类的静态方法	invokestatic
				-反射
				-初始化一个类的子类
				-JAVA虚拟机启动时被标明为启动类的类 (main()方法的类)
				-JDK1.7k开始提供动态语言支持:
					java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,
					REF_invokeStatic句柄对应的类没有初始化，则初始化
		被动使用不会导致进入到初始化阶段
		
		
	类加载：
		类加载时将.class文件中的二进制数据读入到内存中，将其放进方法去，然后再内存中创建一个
		java.lang.Class对象。
		
		加载方式
			-从本地系统中直接加载
			-通过网络下载.class文件
			-从zip，jar等归档文件中加载.class文件
			-从专有数据库中提取.class文件
			-将Java源文件动态编译为.class文件
			
	-XX:+TraceClassLoading
	-XX:+<option>：表示开启option选项
	-XX:-<option>：表示关闭option选项
	-XX:<option>=<value>：表示将option选项的值设置为value
	
	常量在编译阶段会存存入到 调用 这个常量的方法所在的类的常量池中
    本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量类的初始化
    注意：这里指的是将常量存放到了MyTest2的常量池中，之后MyTest2与MyParent2就没有任何关系了
    甚至，我们可以将MyParent2的class文件删除
	
	助记符：
         ldc表示将int,float或是String类型的常量值从常量池中推送至栈顶
         bipush表示将单字节（-128-127）的常量值推送至栈顶
         sipush表示将一个短整形常量值(-32768 - 32767)推送至栈顶
         iconst_1表示将int类型1推送至栈顶 (iconst_1 - iconst_5)
		 
		 
	当一个接口在初始化时，并不要求其父接口都完成了初始化
	只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化
	当一个类在初始化时，也不要求其父接口都完成初始化
	
	类加载的准备阶段会为静态变量赋初始值，初始化阶段则会一行一行的往下执行，为静态变量赋上程序员定义的初始值。
	
	类的生命周期：
		加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 实例化 -> 垃圾回收和对象终结 -> 结束
		类实例化：
			为新的对象分配内存
			为实例变量赋默认值
			为实例变量赋正确的初始值
			Java编译器为它编译的每一个类都至少生成一个实例初始化方法，在Java的class文件中，
			这个实例初始化方法被称为“<init>”。针对源代码中的每一个类的构造方法，java编译器都
			产生一个<init>方法。
			
	类加载器分类：
		Java虚拟机自带的加载器
			根类加载器（Bootstrap）
			扩展类加载器（Extension）
			系统（应用）类加载器（System/App）
		用户自定义的类加载器
			java.lang.ClassLoader的子类
			用户可以定制类的加载方式
	
	类加载器并不需要等到某个类被“首次主动使用”时再加载它。
	
	JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了
	.class文件缺失或不存在的错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)
	如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误
	
	获得ClassLoader的途径
		获得当前类的ClassLoader
			clazz.getClassLoader();
		获得当前线程上下文的ClassLoader
			Thread.currentThred().getContextClassLoader();
		获得系统的ClassLoader
			ClassLoader.getSystemClassLoader();
		获取调用者的ClassLoader
			DriverManager.getCallerClassLoader();
			
	给定类的二进制名称，类加载器应该尝试定位或生成构成类定义的数据。
		定位：比如说磁盘或者网络等其他渠道真实存在的字节码文件，就是采用定位的方式。
		生成：比如说动态代理等技术需要在运行时动态生成字节码文件，就是采用生成的方式。
		
	数组类的类对象不是由类加载器创建的，而是根据Java运行时的需要自动创建的。数组类的类加载器由对应的数组元素决定。
	getClassLoader()与其元素类型的类加载器相同。如果元素类型是基本类型，则数组类没有类加载器。
	
	类加载器默认是支持并行加载的，其子类默认不是并行加载的，如果想要设置子类是并行加载的，则需要调用
	classloader.registerASParallelCapable()方法。
	
	命名空间
		1.每个类加载器都有自己的命名空间；命名空间由该加载器及所有的父加载器所加载的类组成。
		2.在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。
		3.在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。
		
	类的卸载：
		由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。
		
		由用户自己定义的类加载器所加载的类时可以被卸载的。
	