类加载
	在JAVA代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的
	加载：查找并加载类的二进制数据
	连接：
		-验证：确保被加载的类的正确性
		-准备：为类的静态变量分配内存，并将其初始化为默认值
			class Test {
				public static int a = 1;
			}
			在准备阶段会给a赋值为0
		-解析：把类中的符号引用转换为直接引用
	初始化：为类的静态变量赋予正确的初始值
		class Test {
			public static int a = 1;
		}
		在初始化阶段会给a赋值为1
		
	Java程序对类的使用方式分为两种：
		-主动使用
		-被动使用
		
		所有的Java虚拟机实现必须在每个类或接口被Java程序”首次主动使用“时才初始化他们
			主动使用(7种)
				-创建类的实例
				-访问某个类或接口的静态变量，或者对该静态变量赋值 getstatic putstatic
				-调用类的静态方法	invokestatic
				-反射
				-初始化一个类的子类
				-JAVA虚拟机启动时被标明为启动类的类 (main()方法的类)
				-JDK1.7k开始提供动态语言支持:
					java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,
					REF_invokeStatic句柄对应的类没有初始化，则初始化
		被动使用不会导致进入到初始化阶段
		
		
	类加载：
		类加载时将.class文件中的二进制数据读入到内存中，将其放进方法去，然后再内存中创建一个
		java.lang.Class对象。
		
		加载方式
			-从本地系统中直接加载
			-通过网络下载.class文件
			-从zip，jar等归档文件中加载.class文件
			-从专有数据库中提取.class文件
			-将Java源文件动态编译为.class文件
			
	-XX:+TraceClassLoading
	-XX:+<option>：表示开启option选项
	-XX:-<option>：表示关闭option选项
	-XX:<option>=<value>：表示将option选项的值设置为value
	
	常量在编译阶段会存存入到 调用 这个常量的方法所在的类的常量池中
    本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量类的初始化
    注意：这里指的是将常量存放到了MyTest2的常量池中，之后MyTest2与MyParent2就没有任何关系了
    甚至，我们可以将MyParent2的class文件删除
	
	助记符：
         ldc表示将int,float或是String类型的常量值从常量池中推送至栈顶
         bipush表示将单字节（-128-127）的常量值推送至栈顶
         sipush表示将一个短整形常量值(-32768 - 32767)推送至栈顶
         iconst_1表示将int类型1推送至栈顶 (iconst_1 - iconst_5)
		 
		 
	当一个接口在初始化时，并不要求其父接口都完成了初始化
	只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化
	当一个类在初始化时，也不要求其父接口都完成初始化
	
	类加载的准备阶段会为静态变量赋初始值，初始化阶段则会一行一行的往下执行，为静态变量赋上程序员定义的初始值。
	
	类的生命周期：
		加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 实例化 -> 垃圾回收和对象终结 -> 结束
		类实例化：
			为新的对象分配内存
			为实例变量赋默认值
			为实例变量赋正确的初始值
			Java编译器为它编译的每一个类都至少生成一个实例初始化方法，在Java的class文件中，
			这个实例初始化方法被称为“<init>”。针对源代码中的每一个类的构造方法，java编译器都
			产生一个<init>方法。
			
	类加载器分类：
		Java虚拟机自带的加载器
			根类加载器（Bootstrap）
			扩展类加载器（Extension）
			系统（应用）类加载器（System/App）
		用户自定义的类加载器
			java.lang.ClassLoader的子类
			用户可以定制类的加载方式
	
	类加载器并不需要等到某个类被“首次主动使用”时再加载它。
	
	JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了
	.class文件缺失或不存在的错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)
	如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误
	
	获得ClassLoader的途径
		获得当前类的ClassLoader
			clazz.getClassLoader();
		获得当前线程上下文的ClassLoader
			Thread.currentThred().getContextClassLoader();
		获得系统的ClassLoader
			ClassLoader.getSystemClassLoader();
		获取调用者的ClassLoader
			DriverManager.getCallerClassLoader();
			
	给定类的二进制名称，类加载器应该尝试定位或生成构成类定义的数据。
		定位：比如说磁盘或者网络等其他渠道真实存在的字节码文件，就是采用定位的方式。
		生成：比如说动态代理等技术需要在运行时动态生成字节码文件，就是采用生成的方式。
		
	数组类的类对象不是由类加载器创建的，而是根据Java运行时的需要自动创建的。数组类的类加载器由对应的数组元素决定。
	getClassLoader()与其元素类型的类加载器相同。如果元素类型是基本类型，则数组类没有类加载器。
	
	类加载器默认是支持并行加载的，其子类默认不是并行加载的，如果想要设置子类是并行加载的，则需要调用
	classloader.registerASParallelCapable()方法。
	
	命名空间
		1.每个类加载器都有自己的命名空间；命名空间由该加载器及所有的父加载器所加载的类组成。
		2.在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。
		3.在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。
		
	类的卸载：
		由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。
		
		由用户自己定义的类加载器所加载的类时可以被卸载的。
		
	
	类的加载
		在类A中new类B的实例，那么加载类B的类加载器就是加载类A的类加载器，同时加载类B时也遵循双亲委派机制。
		父加载器加载的类里无法访问到子加载器类加载的类，而子加载器加载的类可以访问到父加载器加载的类。
		
	ExtClassLoader(扩展类加载器)
		ExtClassLoader不能直接加载class文件，只能加载jar包
		
	类加载器的双亲委派模型的好处：
		1.可以确保Java核心库的类型安全：所有的Java应用都至少会引用Java.lang.Object类，也就是说在运行期，java.lang.Object这个类
		会被加载到Java虚拟机中；如果这个加载过程是由Java应用自己的类加载器所完成的，那么很可能会在JVM中存在多个版本的java.lang.Object类，
		而且这些类之间还是不兼容的，相互不可见的(正是命名空间在发挥着作用)。
		借助于双亲委派机制，Java核心类库中的类的加载工作都是由启动类加载器来统一完成，从而确保了Java应用所使用的都是同一个版本的
		Java核心类库，他们之间是相互兼容的。
		2.可以确保Java核心类库所提供的类不会被自定义的类所替代。
		3.不同的类加载器可以为相同名称(binary name)的类创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器
		来加载他们即可。不同类加载器所加载的类之间是不兼容的，这就相当于在Java虚拟机内部创建了一个又一个相互隔离的Java类空间，这类技术
		在很多框架中都得到了实际应用。
		
	内建于JVM中的启动类加载器会加载java.lang.ClassLoader以及他的Java平台类，
		当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器与系统类加载器，
		这块特殊的机器码叫做启动类加载器(Bootstrap ClassLoader)

		启动类加载器并不是Java类，而其他的加载器则都是Java类，
		启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。

		所有类加载器（除了启动类加载器）都被实现为Java类。不过，总归要有一个组件来加载第一个Java类加载器，
		从而整个加载过程才能够被顺利进行下去，加载第一个纯Java类加载器就是启动类加载器的职责。

		启动类加载器还会负责加载供JRE正常运行所需要的基本组件，这包括java.util与java.lang包中的类等等。

		要将自定义的类加载器作为系统类加载器的条件
			1.设置系统属性java.system.class.loader=com.xx.xx.A
			2.自定义类加载器必须有一个构造函数为A(ClassLoader parent)，这个构造函数将被系统调用
		   注意:自定义类加载器作为系统类加载器时，其父委托加载器是AppClassLoader
		   
	当前类加载器(Current Classloader)
                每个类都会使用自己的类加载器(即加载自身的类加载器)去加载自己所依赖的类，
                如果ClassX引用了ClassY,那么ClassX的类加载器就会去加载ClassY(前提是ClassY尚未被加载)
            线程上下文类加载器(Context Classloader)
                线程上下文类加载器是从JDK1.2开始引入的，类Thread中的getContextClassLoader()与setContextClassLoader(ClassLoader cl)
                分别用来获取和设置线程上下文类加载器

            如果没有通过setContextClassLoader(ClassLoadr cl)进行设置的话，线程将继承其父线程的上下文类加载器
            Java应用运行时的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过该类加载器来加载类与资源。

            线程上下文类加载器的重要性：
                SPI(Service Provider Interface)

                父ClassLoader可以使用当前线程Thread.currentThread().getContextClassloader()所指定的classLoader所加载的类。
                这就改变了父Classloader不能使用子Classloader或是与其没有直接父子关闭的ClassLoader加载的类的情况，即改变了双亲委托模型。

                线程上下文类加载器就是当前线程的Current ClassLoader。

                在双亲委托模型下，类加载是由上至下的，即下层的类加载器会委托上层进行加载。但是对于SPI来说，有些接口是Java核心库所提供的，
                而Java核心库是由启动类加载器来加载的，而这些接口的实现却来自于不同的jar包(厂商提供)，Java的启动类加载器是不会加载其他来源
                的jar包，这样传统的双亲委托模型就无法满足SPI的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于
                接口实现类的加载。
				
	线程上下文类加载器的一般使用模式(获取 - 使用 - 还原)

        ClassLoader targetTccl = null; // new MyClassLoader();

        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();

        try {
            Thread.currentThread().setContextClassLoader(targetTccl);
            myMethod();
        } finally {
            Thread.currentThread().setContextClassLoader(classLoader);
        }

        myMethod里面则调用了Thread.currentThread().getContextClassLoader()，获取当前线程的上下文类加载器做某些事情。

        如果一个类由类加载器A加载，那么这个类的依赖类也是由相同的类加载器加载的 (如果该依赖类之前没有被加载过的话)

        ContextClassLoader的作用是为了破坏Java的类加载委托机制。

        当高层提供了统一的接口让低层去实现，同时又要在高层加载 (或实例化) 低层的类时，就必须要通过线程上下文类加载器来
        帮助高层的ClassLoader找到并加载该类。
		
	