# 自旋锁的价值
## 基本概念
### Monitor的实现
JVM中的同步是基于进入与退出 **监视器对象(管程对象)(Monitor)** 来实现的，每个对象实例都会有一个`Monitor`对象，`Monitor`对象会和`Java对象`一同创建并销毁。`Monitor`对象是由C++来实现的。

### synchronized互斥是如何保证的
当多个线程同时访问一段同步代码时，这些线程会被放到一个`EntryList`集合中，处于阻塞状态的线程都会被放到该列表当中。接下来，当线程获取到对象的`Monitor`时，`Monitor`是依赖于底层操作系统的`mutex lock`来实现互斥的，线程获取`mutex`成功，则会持有该`mutex`，这时其他线程就无法获取到该`mutex`。

如果线程调用了`wait`方法，那么该线程就会释放掉所持有的`mutex`，并且该线程会进入到`waitset`集合(等待集合)中，等待下一次被其他线程调用`notify/notifyAll`唤醒。如果当前线程顺利执行完毕方法，那么它也会释放掉所持有的`mutex`。

### 总结
同步锁在这种实现方式当中，因为`Monitor`是依赖于底层的操作系统实现，这样就存在`用户态`与`内核态`之间的切换，所以会增加性能开销。

通过对象互斥锁的概念来保证共享数据操作的完整性。每个对象都对应有一个可称为【互斥锁】的标记，这个标记用于保证任何时刻，只能有一个线程访问该对象。

---

## 自旋锁对于synchronized的意义
### 提出问题
那些处于`EntryList`与`Waitset`中的线程均处于阻塞状态，阻塞操作是由操作系统来完成的，在Linux下是通过`pthred_mutex_lock`函数实现的。线程被阻塞后便会进入到`内核调度状态`，这会导致系统在`用户态`与`内核态`之间来回切换，严重影响锁的性能。

### 解决问题
解决上述问题的办法便是**自旋**(Spin)。其原理是：发生对`Monitor`的争用时，若`Owner`(锁的持有者)能够在很短的时间内释放掉锁，则那些正在争用的线程就可以**稍微等待一下**(即所谓的自旋)，在`Owner`线程释放锁之后，争用线程可能会立刻获取到锁，从而避免了系统阻塞。不过，当`Owner`运行的时间超过了临界值后，争用线程自旋一段时间后依然无法获取到锁，这时争用线程则会停止自旋而进入到阻塞状态。所以总体思想是：**先自旋，不成功再进行阻塞，尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有极大的性能提升。** 显然，自旋在多处理器(多核心)上才有意义。