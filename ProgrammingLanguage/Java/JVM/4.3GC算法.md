# GC算法
## 标记-清除算法(Mark-Sweep)
算法分为 **标记** 和 **清除** 两个阶段，首先标记出所有需要回收的对象，然后回收所有需要回收的对象。

### 缺点
* 效率问题：标记和清理两个过程效率都不高(堆越大，GC越慢)
* 空间问题：标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前出发另一次的垃圾搜集动作(GC次数越多，碎片越严重)

## 标记-整理算法(Mark-Compact)
标记过程等同于 **标记-清除** 算法，但后续的步骤不再是直接清理，而是令所有存活的对象向一端移动，然后直接清理掉这端边界以外的内存。

### 优点
没有内存碎片

### 缺点
比 **标记-清除** 算法耗费更多的时间进行compact(压缩整理)

## 复制算法(Copying)
将可用内存划分为两块，每次只使用其中的一块，当半区内存用完了，仅将还存活的对象复制到另一块上面，然后就把原来整块内存空间一次性清理掉
### 优点
* 实现简单，运行高效，不存在内存碎片化

### 缺点
* 复制收集算法在对象存活率高的时候，效率有所下降
* 将内存缩小为原来的一半，代价高昂

### 应用实例
* 应用于 **新生代** 的垃圾收集

## 分代算法(Generational)
根据对象的不同存活周期将内存划分为几块，对每块采用不同的的算法进行垃圾回收

一般将Java堆分为 **新生代** 和 **老年代**。
* 新生代
  采用复制收集算法
* 老年代
  采用标记清除算法或标记整理算法
* Hotspot JVM6中划分为三个代：**年轻代**(Young Genration)、**老年代**(Old Genration)和**永久代**(Permanent Generation)。
![分代](/assets/分代.png)
```mermaid
graph LR
A[Eden满] --Eden中存活--> B[FromSurvivor]
B -.-> C[FromSurvivor满]
C --FromSurvivor中存活&Eden中存活--> D[ToSurvivor]
D -.-> E[ToSurvivor满]
E --ToSurvivor中存活--> F[Tenured Space]
```
* 永久代
并 **不属于堆**,但是GC会涉及到这个区域，且在JAVA8中已经被废弃
