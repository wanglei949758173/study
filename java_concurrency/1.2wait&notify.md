# wait
要想调用一个对象A的`wait()`方法，首先要确保调用了`wait()`方法的线程持有了对象的**monitor(锁)**

当调用`wait()`方法后，该线程就会释放掉该对象的锁，然后进入到等待状态(wait set)

当线程调用了`wait()`方法后进入等待状态时，它可以等待其他线程调用相同对象的`notify()`或`notifyAll()`方法使得自己被唤醒

一旦这个线程被其他线程唤醒后，该线程就会与其他线程一同开始竞争这个锁(公平竞争)；只有当该线程获得了这个对象的锁后，线程才会继续往下执行

调用`wait()`方法的代码片段需要放在一个synchronize块或是synchronize方法中，这样才可以确保线程在调用`wait()`方法前已获取了对象的锁

总是被使用在循环当中

# notify
当调用对象的`notify()`方法时，它会随机唤醒该对象等待集合(wait set)中的任意一个线程，当某个线程被唤醒后，它就会与其他线程一同竞争对象的锁

当调用对象的`notifyAll()`方法时，它会唤醒该对象等待集合(wait set)中的所有线程，这些线程被唤醒后，又会开始竞争对象的锁

## 线程可以被唤醒的4种情况
其他Thread执行了`notify()`方法，且被唤醒的线程恰巧是该线程

其他线程执行了`notifyAll()`方法

其他线程 **interrupt(打断)** 了该线程

线程等待已经超过了设置的**timeout**，如果`timeout=0`，则代表线程会一直等待，直到被其他线程唤醒


# sleep
调用`Thread`的`sleep()`方法时，当前线程是不会释放锁的

