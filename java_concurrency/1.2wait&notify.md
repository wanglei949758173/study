# wait
1. 要想调用一个对象A的`wait()`方法，当前线程必须持有A的**monitor(锁)**
2. 当在线程T中调用了一个对象A的`wait()`方法时，则线程T也就释放了A的锁
3. 总是被使用在循环当中
4. 调用`wait()`后，当前线程T会进入对象object的等待集合
5. 线程T被唤醒后，首先会从对象object的等待集合中移除线程T，接着线程T和其他线程去争夺对象object的同步权

## 线程T wait之后被唤醒的4中情况
1. 其他Thread执行了`notify()`方法，且被唤醒的线程恰巧是线程T
2. 其他线程执行了`notifyAll()`方法
3. 其他线程 **interrupt(打断)** 了线程T
4. 线程T等待已经超过了设置的**timeout**，如果`timeout=0`，则代表线程会一直等待，直到被其他线程唤醒


# sleep
1. 调用`Thread`的`sleep()`方法时，当前线程是不会释放锁的

# notify
1. 只会唤醒一个线程，会唤醒哪个线程是随机的