# 互斥锁
## 互斥锁的属性：
1. PTHREAD_MUTEX_TIMED_NP：这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将会形成一个等待队列，并且在解锁后按照优先级获取到锁。这种策略可以确保资源分配的公平性。

2. PTHREAD_MUTEX_RECURSIVE_NP：嵌套锁。允许一个线程对同一个锁获取多次，并通过unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新进行竞争。

3. PTHREAD_MUTEX_ERRORCHECK_NP：检错锁。如果一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同，这样就保证了当不允许多次加锁时不会出现最简单情况下的死锁。

4. PTHREAD_MUTEX_ADAPTIVE_NP：适应锁，动作最简单的锁类型，仅仅等待解锁后重新竞争。

---

在JDK1.5之前，我们若想实现线程同步，只能通过`synchronized`关键字这一种方式；底层，Java是通过`synchronized`关键字来做到数据的原子性维护的；`synchronized`关键字是JVM实现的一种内置锁，从底层角度来说，这种锁的获取与释放都是由JVM帮助我们隐式实现的。

从JDK1.5开始，并发包引入了Lock锁，Lock同步锁是基于Java来实现的，因此锁的获取与释放都是通过Java代码来实现与控制的；然而，synchronized是基于底层操作系统的Mutex Lock来实现的，每次对锁的获取与释放动作都会带来用户态与内核态之间的切换，这种切换会极大地增加系统的负担；在并发量较高时，也就是说锁的竞争比较激烈时，synchronized锁在性能上的表现就非常差。

从JDK1.6开始，synchronized锁的实现发生了很大的变化；JVM引入了相应的优化手段来提升synchronized锁的性能，这种提升涉及到偏向锁、轻量级锁及重量级锁等，从而减少锁的竞争所带来的用户态与内核态之间的切换；这种锁的优化实际上是通过Java对象头中的一些标志位来去实现的；对于锁的访问与改变，实际上都与Java对象头息息相关。

从JDK1.6开始，对象实例在堆当中会被划分为三个组成部分：对象头、实例数据与对齐填充。

对象头主要也是由3块内容来构成：
1. Mark Word
2. 指向类的指针
3. 数组长度

其中Mark Word (它记录了对象、锁及垃圾回收相关的信息，在64位的JVM中，其长度也是64bit)的位信息包括了如下组成的部分：
1. 无锁标记
2. 偏向锁标记
3. 轻量级锁标记
4. 重量级锁标记
5. GC标记

对于synchronized锁来说，锁的升级主要都是通过Mark Word中的锁标志位与是否是偏向锁标志位来达成的；synchronized关键字所对应的锁都是先从偏向锁开始，随着锁竞争的不断升级，逐步演化至轻量级锁，最后则变成了重量级锁

对于锁的演化来说，它会经历如下阶段：
无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

偏向锁：
针对于一个线程来说，如果线程A获取到了对象obj的Monitor，则对象obj的偏向锁标记会记录为偏向锁，且对象obj中有一个引用记录了当前获取到锁的线程的id(即线程A的id)，这样，当A线程再次需要获取对象obj的Monitor时，且在两次获取对象obj的Monitor之间没有其他线程间获取到对象的obj锁时，线程A直接会拿到obj的Monitor，这样就减少了用户态到内核态的切换，从而提升了性能