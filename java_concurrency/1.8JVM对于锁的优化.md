# JVM对于锁的优化
在JDK1.5之前，我们若想实现线程同步，只能通过`synchronized`关键字这一种方式；底层，Java是通过`synchronized`关键字来做到数据的原子性维护的；`synchronized`关键字是JVM实现的一种内置锁，从底层角度来说，这种锁的获取与释放都是由JVM帮助我们隐式实现的。

从JDK1.5开始，并发包引入了`Lock`锁，`Lock`同步锁是基于Java来实现的，因此锁的获取与释放都是通过Java代码来实现与控制的；然而，synchronized是基于底层操作系统的`Mutex Lock`来实现的，每次对锁的获取与释放动作都会带来用户态与内核态之间的切换，这种切换会极大地增加系统的负担；在并发量较高时，也就是说锁的竞争比较激烈时，`synchronized`锁在性能上的表现就非常差。

从JDK1.6开始，`synchronized`锁的实现发生了很大的变化；JVM引入了相应的优化手段来提升`synchronized`锁的性能，这种提升涉及到**偏向锁**、**轻量级锁**及**重量级锁**等，从而减少锁的竞争所带来的用户态与内核态之间的切换；这种锁的优化实际上是**通过Java对象头中的一些标志位来去实现**的；对于锁的访问与改变，实际上都与Java对象头息息相关。

---

## 对象的结构
从JDK1.6开始，对象实例在堆当中会被划分为三个组成部分：**对象头**、**实例数据**与**对齐填充**。


### 对象头的结构
对象头主要也是由3块内容来构成：
1. Mark Word
2. 指向类元数据的指针
3. 数组长度

其中Mark Word (它记录了对象、锁及垃圾回收相关的信息，在64位的JVM中，其长度也是64bit)的位信息包括了如下组成的部分：
1. 无锁标记
2. 偏向锁标记
3. 轻量级锁标记
4. 重量级锁标记
5. GC标记

对于`synchronized`锁来说，锁的升级主要都是通过**Mark Word**中的**锁标志位**与**是否是偏向锁标志位**来达成的；`synchronized`关键字所对应的锁都是先从偏向锁开始，随着锁竞争的不断升级，逐步演化至轻量级锁，最后则变成了重量级锁

对于锁的演化来说，它会经历如下阶段：
**无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁**

---

## 偏向锁：
**针对于一个线程来说的。**

它的主要作用就是**优化同一个线程获取同一个锁的情况**。如果一个`synchronized`方法被一个线程访问，那么这个方法所在的对象就会在其`Mark Word`中将**偏向锁进行标记**，同时还会有一个字段来**存储该线程的ID**;当这个线程再次访问同一个`synchronized`方法时，它会检查这个对象的`Mark Word`的偏向锁标记以及是否指向了其线程ID,如果是的话，那么该线程就无需再去进入管程(Monitor)了，而是直接进入到该方法体中。

**如果是另外一个线程访问这个`synchronized`方法，那么实际情况会如何呢？**
答：**当前线程**的偏向锁会被取消掉。

## 轻量级锁
若第一个线程已经获取到了当前对象的锁，这时第二个线程又开始尝试争抢该对象的锁，由于该对象的锁已经被第一个线程获取到，因此它是偏向锁，而第二个线程在争抢时，会发现该对象头中的`Mark Word`已经是偏向锁，但里面存储的线程ID并不是自己(是第一个线程)，那么它会进行**CAS(compare and swap)**，从而获取到锁，这里面会存在两种情况：
1. 获取锁成功：那么它会直接将`Mark Word`中的线程ID由第一个线程变成自己(偏向锁标记位保持不变)，这样该对象依然会保持偏向锁的状态。
2. 获取锁失败：则表示这时可能会有多个线程同时在尝试争抢该对象的锁，那么这时偏向锁就会进行升级，升级为轻量级锁

总结：**线程T1拥有持有锁Lock，线程T2和T3同时竞争锁Lock，这样就会导致偏向锁升级为轻量级锁**

## 重量级锁
**自旋失败(时间/次数超过阈值)**，线程从用户态进入到了内核态。
