# 安全区&安全区域
## 枚举根节点
当执行系统停顿下来后，并 **不需要一个不漏地检查完所有执行上下文和全局的引用位置**，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为 **OopMap(标识栈上的哪个数据是什么样的类型)的数据结构**来达到这个目的

## 安全点
在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，**如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得更高**。

总结：**OopMap如果频繁变化会影响GC效率**

实际上，HotSpot并没有为每条指令都生成OopMap，而只是在“特定的位置”记录了这些信息，这些位置称为 **安全点(Safepoint)** ，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。

SafePoint的选定既**不能太少**以至于让GC等待时间太长，也**不能过于频繁**以至于过分增大运行时的负载。所以，安全点的选定基本上是以 **“是否具有让程序长时间执行的特征”** 为标准进行选定的——因为每条指令执行的时间非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如 **方法调用、循环跳转、异常跳转** 等，所以具有这些功能的指令才会产生SafePoint。

对于SafePoint，另一个需要考虑的问题是如何在GC发生时让所有线程(这里不包括执行JNI调用的线程)“跑”到最近的安全点上再停顿下来：**抢占式中断(Preemptive Suspension)** 和 **主动式中断(Voluntary Suspension)**

### 抢占式中断
它不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果有线程中断的地方不在安全点上，就恢复线程，让它”跑“到安全点上。

### 主动式中断
当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

### 现在几乎没有虚拟机采用抢占式中断来暂停线程从而响应GC事件

## 安全区域
*在使用SafePoint似乎已经完美解决了如何进入GC的问题，但实际上情况却并不一定。SafePoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的SafePoint。**但如果程序“不执行”的时候呢？** 所谓程序不执行就是没有分配CPU时间，典型的例子就是出于 **Sleep状态或者Blocked状态**，这时候线程无法响应JVM的中断请求，JVM也显然不太可能等待线程重新分配CPU时间。对于这种情况，就需要 **安全区域(Safe Region)** 来解决了。

在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用了管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举(或者是整个GC过程)，如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。