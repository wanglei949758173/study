1.NioEventLoopGroup
    构造函数参数可以设定启动的线程数，默认启动的线程数为cpu核心数x2
2.EventLoopGroup
    EventLoopGroup里边包装了多个EventLoop，可以向EventLoopGroup中注册Channel
3.EventExecutorGroup
    EventExecutorGroup里边包装了多个EventExecutor，EventExecutorGroup提供获得EventExecutor的方法，同时也维护自己的生命周期。
4.Executor
    用到了命令模式，提交一个命令给Executor，然后Executor去执行
5.serverBootstrap.group(bossGroup,workerGroup).channel(
                      NioServerSocketChannel.class).childHandler(new MyServerInitializer());
    这行代码执行完，仅仅只是完成了对Bootstrap类的成员属性的赋值工作。
6.netty Future相对于JDK Future的优点？
    a.JDK的Future无法知道任务是什么时候完成的，因此无法知道在什么时候调用Future.get()合适
    而Netty的Future通过观察者模式解决了此问题
    b.netty中的Future的isSuccess方法优于JDK中的isDone方法，因为取消操作也会让isDone返回为true，从而无法得知任务执行完了还是取消了。
7.ChannelFuture
    封装了Channel的Future
                                          +---------------------------+
                                          | Completed successfully    |
                                          +---------------------------+
                                     +---->      isDone() = true      |
     +--------------------------+    |    |   isSuccess() = true      |
     |        Uncompleted       |    |    +===========================+
     +--------------------------+    |    | Completed with failure    |
     |      isDone() = false    |    |    +---------------------------+
     |   isSuccess() = false    |----+---->      isDone() = true      |
     | isCancelled() = false    |    |    |       cause() = non-null  |
     |       cause() = null     |    |    +===========================+
     +--------------------------+    |    | Completed by cancellation |
                                     |    +---------------------------+
                                     +---->      isDone() = true      |
                                          | isCancelled() = true      |
                                          +---------------------------+
    建议首先选用addListener(GenericFutureListener)而不是选用await()方法
        addListener(GenericFutureListener)
            优点：
                非阻塞，回调方式
            缺点：
                如果对事件驱动不熟则不能保证监听器的执行顺序
        await()
            优点：
                可以比较容易实现顺序的调用
            缺点：
                阻塞
                有些情况下会产生死锁
                    在ChannelHandler中调用await()方法会产生死锁
                    eventHandler通常被IO线程调用,await()方法等待I/O完成，而I/O又被await()阻塞，因此产生了死锁。
     I/O超时和await超时
        await(long)等方法指定的超时和I/O超时无关
          // BAD - NEVER DO THIS
          {@link Bootstrap} b = ...;
          {@link ChannelFuture} f = b.connect(...);
          f.awaitUninterruptibly(10, TimeUnit.SECONDS);
          if (f.isCancelled()) {
              // Connection attempt cancelled by user
          } else if (!f.isSuccess()) {
              // You might get a NullPointerException here because the future
              // might not be completed yet. 连接可能没有建立
              f.cause().printStackTrace();
          } else {
              // Connection established successfully
          }

          // GOOD
          {@link Bootstrap} b = ...;
          // Configure the connect timeout option.
          <b>b.option({@link ChannelOption}.CONNECT_TIMEOUT_MILLIS, 10000);</b>
          {@link ChannelFuture} f = b.connect(...);
          f.awaitUninterruptibly();

          // Now we are sure the future is completed.
          assert f.isDone();

          if (f.isCancelled()) {
              // Connection attempt cancelled by user
          } else if (!f.isSuccess()) {
              f.cause().printStackTrace();
          } else {
              // Connection established successfully
          }
          </pre>

    AbstractBootstrap
        initAndRegister
            init方法
                1.完成了option和attribute的赋值
                2.将用户所配置的handler添加到ChannelPipeline的最后
                    ChannelHandler handler = config.handler();
                    if (handler != null) {
                        pipeline.addLast(handler);
                    }
                3.在管道中添加了接收器ServerBootstrapAcceptor

传统客户端服务器端的3个问题
    1.一个Socket对应一个线程，而一个服务器的线程资源是有限的
    2.线程越创建越多，线程上下文的切换会严重损耗性能
    3.当数据还未通过网络传递过来或其他I/O事件还未完成时，线程依然被占用者，且没有为用户提供任何服务，这样也就导致了资源的浪费。

Reactor模式的角色构成(Reactor模式一共有5种角色构成)
    1.Handle (句柄或是描述符)：本质上是一种资源，是由操作系统提供的；该资源用于表示一个个的事件，比如说文件描述符，或是针对
    网络中的Socket描述符。事件既可以来自于外部，也可以来自内部；外部事件比如说客户端的连接请求，客户端发送过来的数据等；内部事件
    比如说操作系统产生的定时器事件等。它本质上就是一个文件描述符。Handle是事件的发源地。
    2.Synchronous Event Demultiplexer {同步事件分离器}：它本身是一个系统调用，用于等待事件的发生{事件可能是一个，也可能是多个}。
    调用方法在调用它的时候会被阻塞，一直阻塞到同步事件分离器上有事件产生为止。对于Linux来说，同步事件分离器指的就是常用的I/O多路复用
    机制，比如说select、poll、epoll等。在Java NIO领域中，同步事件分离器对应的组件就是Selector;对应
    的阻塞方法就是select方法。
    3.Event Handler (事件处理器)：本身由多个回调方法构成，这些回调方法构成了与应用相关的对于某个事件
    的反馈机制。Netty相比于Java NIO来说，在事件处理器这个角色上进行了一个升级，它为我们开发者提供了
    大量的回调方法，供我们在特定事件产生时实现相应的回调方法进行业务逻辑的处理。
    4.Concrete Handler (具体事件处理器): 是事件处理器的实现。它本身实现了事件处理器的各个
    回调方法，从而实现了特定的业务逻辑。它本质上就是我们所编写的一个个的处理器实现。
    5.Initiation Dispatcher (初始分发器): 实际上就是Reactor角色。它本身定义了一些
    规范，这些规范用于控制事件的调度方式，同时又提供了应用进行事件处理器的注册、删除
    等设施。它本身是整个事件处理器的核心所在，Initiation Dispatcher会通过同步事件分离器
    来等待事件的发生。一旦事件发生，Initiation Dispatcher首先会分离出每一个事件，然后
    调用事件处理器，最后调用相关的回调方法来处理这些事件。

 --------------------------------------------------------

 Reactor模式的流程

 1.当应用向Initiation Dispatcher注册具体的事件时，应用会标识出该事件处理器
 希望Initiation Dispatcher在某个事件发生时向其通知的该事件，该事件与Handle关联。
 2.Initiation Dispatcher会要求每个事件处理器向其传递内部的Handle。该Handle向操作系统标识了事件处理器。
 3.当所有的事件处理器注册完毕后，应用会调用handle_events方法来启动Initiation Dispatcher的事件循环。这时，
 Initiation Dispatcher会将每个注册的事件管理器的handle合并起来，并使用同步事件分离器等待这些事件的发生。比如说，
 TCP协议层会使用select同步事件分离器操作来等待客户端发送的数据到达连接的Socket handle上。
 4.当与某个事件源对应的Handle变为ready状态时(比如说，TCP socket等待读状态时)，同步事件分离器就会通知Initiation Dispatcher
 5.Initiation Dispatcher会出发事件处理器的回调方法，从而相应这个处于ready状态的Handle。当事件发生时，
 Initiation Dispatcher会将被事件激活的Handle作为【key】来寻找并分发恰当的事件处理器回调方法。
 6.Initiation Dispatcher会回调事件处理器的handle_event回调方法来执行特定于应用的功能（开发者自己所编写的功能），
 从而响应这个事件。所发生的事件类型可以作为该方法参数并被该方法内部使用来执行额外的特定于服务的分离与分发。

ChannelOption
    提供了关于TCP/IP相关的底层的一些设定
AttributeKey
    提供了在channel上保存业务的一些属性，以达到让Pipeline中下一个HandlerEvent获取到该属性的目的。

ChannelHandler、ChannelPipeline、ChannelHandlerContext之间的关系
    默认情况下，一个handler会与一个handlerContext相对应
    如果将一个handler添加到了一个ChannelPipeline上多次获将一个handler添加到了不同的ChannelPipeline上，就会有多个
    handlerContext与handler相对应。
    总结，一个handler添加到了ChannelPipeline几次，就有几个handlerContext与handler相对应。
    ChannelPipeline中实际保存的是ChannelHandlerContext对象，而ChannelHandlerContext中又有与之对应的ChannelHandler对象
    ChannelHandlerContext持有着Channel对象、ChannelPipeline对象、ChannelHandler对象

