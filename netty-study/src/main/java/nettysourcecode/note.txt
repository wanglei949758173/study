1.NioEventLoopGroup
    构造函数参数可以设定启动的线程数，默认启动的线程数为cpu核心数x2
2.EventLoopGroup
    EventLoopGroup里边包装了多个EventLoop，可以向EventLoopGroup中注册Channel
3.EventExecutorGroup
    EventExecutorGroup里边包装了多个EventExecutor，EventExecutorGroup提供获得EventExecutor的方法，同时也维护自己的生命周期。
4.Executor
    用到了命令模式，提交一个命令给Executor，然后Executor去执行
5.serverBootstrap.group(bossGroup,workerGroup).channel(
                      NioServerSocketChannel.class).childHandler(new MyServerInitializer());
    这行代码执行完，仅仅只是完成了对Bootstrap类的成员属性的赋值工作。
6.netty Future相对于JDK Future的优点？
    a.JDK的Future无法知道任务是什么时候完成的，因此无法知道在什么时候调用Future.get()合适
    而Netty的Future通过观察者模式解决了此问题
    b.netty中的Future的isSuccess方法优于JDK中的isDone方法，因为取消操作也会让isDone返回为true，从而无法得知任务执行完了还是取消了。
7.ChannelFuture
    封装了Channel的Future
                                          +---------------------------+
                                          | Completed successfully    |
                                          +---------------------------+
                                     +---->      isDone() = true      |
     +--------------------------+    |    |   isSuccess() = true      |
     |        Uncompleted       |    |    +===========================+
     +--------------------------+    |    | Completed with failure    |
     |      isDone() = false    |    |    +---------------------------+
     |   isSuccess() = false    |----+---->      isDone() = true      |
     | isCancelled() = false    |    |    |       cause() = non-null  |
     |       cause() = null     |    |    +===========================+
     +--------------------------+    |    | Completed by cancellation |
                                     |    +---------------------------+
                                     +---->      isDone() = true      |
                                          | isCancelled() = true      |
                                          +---------------------------+
    建议首先选用addListener(GenericFutureListener)而不是选用await()方法
        addListener(GenericFutureListener)
            优点：
                非阻塞，回调方式
            缺点：
                如果对事件驱动不熟则不能保证监听器的执行顺序
        await()
            优点：
                可以比较容易实现顺序的调用
            缺点：
                阻塞
                有些情况下会产生死锁
                    在ChannelHandler中调用await()方法会产生死锁
                    eventHandler通常被IO线程调用,await()方法等待I/O完成，而I/O又被await()阻塞，因此产生了死锁。
     I/O超时和await超时
        await(long)等方法指定的超时和I/O超时无关
          // BAD - NEVER DO THIS
          {@link Bootstrap} b = ...;
          {@link ChannelFuture} f = b.connect(...);
          f.awaitUninterruptibly(10, TimeUnit.SECONDS);
          if (f.isCancelled()) {
              // Connection attempt cancelled by user
          } else if (!f.isSuccess()) {
              // You might get a NullPointerException here because the future
              // might not be completed yet. 连接可能没有建立
              f.cause().printStackTrace();
          } else {
              // Connection established successfully
          }

          // GOOD
          {@link Bootstrap} b = ...;
          // Configure the connect timeout option.
          <b>b.option({@link ChannelOption}.CONNECT_TIMEOUT_MILLIS, 10000);</b>
          {@link ChannelFuture} f = b.connect(...);
          f.awaitUninterruptibly();

          // Now we are sure the future is completed.
          assert f.isDone();

          if (f.isCancelled()) {
              // Connection attempt cancelled by user
          } else if (!f.isSuccess()) {
              f.cause().printStackTrace();
          } else {
              // Connection established successfully
          }
          </pre>

    AbstractBootstrap
        initAndRegister
            init方法
                1.完成了option和attribute的赋值
                2.将用户所配置的handler添加到ChannelPipeline的最后
                    ChannelHandler handler = config.handler();
                    if (handler != null) {
                        pipeline.addLast(handler);
                    }
                3.在管道中添加了接收器ServerBootstrapAcceptor