
ChannelOption
    提供了关于TCP/IP相关的底层的一些设定
AttributeKey
    提供了在channel上保存业务的一些属性，以达到让Pipeline中下一个HandlerEvent获取到该属性的目的。

		
		通常会有两种实现方式：
			1.在ChannelHandler的回调方法中，使用自己定义的业务线程池，这样可以实现异步调用。
			2.借助于Netty提供的向ChannelPipeline添加ChannelHandler时调用的addLast方法来传递EventExecutor。
			说明：默认情况下(调用addLast(handler))，ChannelHandler中的回调方法是由I/O线程所执行，
			如果调用了ChannelPipeline addLast(EventExecutorGroup group,ChannelHandler... handlers)方法，那么ChannelHandler中的
			回到方法就是有参数中的EventExecutorGroup线程组来执行的。
	
			
	
	
	AtomicIntegerFieldUpdater要点总结：
		1.更新器更新的必须是Int类型的变量，不能是其包装类型。
		2.更新器更新的必须是volatile类型变量，确保线程之间共享变量时的立即可见性。
		3.变量不能是static的，必须要是实例变量。因为Unsafe.objectFiledOffest()方法不支持静态变量(CAS操作本质上是通过对象
		实例的偏移量来直接进行赋值)。
		4.更新器只能修改它可见范围内的变量，因为更新器是通过反射来得到这个变量，如果变量不可见就会报错。
		
		如果更新的变量时包装类型，那么可以使用AtomicReferenceFieldUpdater来进行更新。
		
	Netty中为什么使用AtomicIntegerFieldUpdater而不使用AtomicInteger来保证引用计数的原子性？
		答：因为AtomicIntegerFieldUpdater被定义为static类型的变量，全局只有一份，这样所有的ByteBuf都共享这个更新器，减少了内存的
		占用。

		
	 ReplayingDecoder<S>笔记：
		1.继承自ByteToMessageDecoder，
		2.解码时不用判断可读字节数，可以直接读取out.add(in.readLong())
		public class IntegerHeaderFrameDecoder extends ByteToMessageDecoder {
  
		// ByteToMessageDecoder实现解码  数据结构(header:10,body:4366DD)
         @Override
		 protected void decode(ChannelHandlerContext ctx,
								 ByteBuf buf, List<Object> out) throws Exception {
	  
		   if (buf.readableBytes() < 4) {
			  return;
		   }
	  
		   buf.markReaderIndex();
		   int length = buf.readInt();
	  
		   if (buf.readableBytes() < length) {
			  buf.resetReaderIndex();
			  return;
		   }
	  
		   out.add(buf.readBytes(length));
		 }
	   }
	   
	   // 使用ReplayingDecoder进行替换的方式
	   public class IntegerHeaderFrameDecoder
			extends ReplayingDecoder<Void> {
	  
		 protected void decode(ChannelHandlerContext ctx,
								 ByteBuf buf) throws Exception {
	  
		   out.add(buf.readBytes(buf.readInt()));
		 }
	   }
	   
	   
	   
	   public class MyDecoder extends ReplayingDecoder<Void> {
  
		 private final Queue<Integer> values = new LinkedList<Integer>();
	  
		  @Override
		 public void decode(.., ByteBuf buf, List<Object> out) throws Exception {
	  
		   // A message contains 2 integers.
		   values.offer(buf.readInt()); // a
		   values.offer(buf.readInt()); // b
	  
		   // 断言有可能失败，因为此方法可能会被调用多次，如果buf中的内容第一次为6个字节,则执行到b时，ReaderIndex会被重置，
		   // 因此第二次读时，如果buf中有8个字节，则values.size = 1 + 2 =3
		   assert values.size() == 2;
		   out.add(values.poll() + values.poll());
		 }
	   }
	   
	   // 正确的实现方式
	   public class MyDecoder extends ReplayingDecoder<Void> {
  
		 private final Queue<Integer> values = new LinkedList<Integer>();
	  
		  @Override
		 public void decode(.., ByteBuf buf, List<Object> out) throws Exception {
	  
		   // Revert the state of the variable that might have been changed
		   // since the last partial decode.
		   values.clear();
	  
		   // A message contains 2 integers.
		   values.offer(buf.readInt());
		   values.offer(buf.readInt());
	  
		   // Now we know this assertion will never fail.
		   assert values.size() == 2;
		   out.add(values.poll() + values.poll());
		 }
	   }
	   
	   有状态的Decoder的实现
	   public enum MyDecoderState {
			 READ_LENGTH,
			 READ_CONTENT;
	   }
	  
	   public class IntegerHeaderFrameDecoder
			extends ReplayingDecoder<MyDecoderState> {
	  
		 private int length;
	  
		 public IntegerHeaderFrameDecoder() {
		   // Set the initial state.
		   super(MyDecoderState.READ_LENGTH);
		 }
	  
		  @Override
		 protected void decode(ChannelHandlerContext ctx,
								 ByteBuf buf, List<Object> out) throws Exception {
		   switch (state()) {
		   case READ_LENGTH:
			 length = buf.readInt();
			 checkpoint(MyDecoderState.READ_CONTENT);
		   case READ_CONTENT:
			 ByteBuf frame = buf.readBytes(length);
			 checkpoint(MyDecoderState.READ_LENGTH);
			 out.add(frame);
			 break;
		   default:
			 throw new Error("Shouldn't reach here.");
		   }
		 }
	   }
	   
	   无参数的checkpoint()的调用
	   public class IntegerHeaderFrameDecoder
        extends ReplayingDecoder<Void> {
  
		 private boolean readLength;
		 private int length;
	  
		  @Override
		 protected void decode(ChannelHandlerContext ctx,
								 ByteBuf buf, List<Object> out) throws Exception {
		   if (!readLength) {
			 length = buf.readInt();
			 readLength = true;
			 checkpoint();
		   }
	  
		   if (readLength) {
			 ByteBuf frame = buf.readBytes(length);
			 readLength = false;
			 checkpoint();
			 out.add(frame);
		   }
		 }
	   }
	   
	   多个解码器的使用
	    public class FirstDecoder extends ReplayingDecoder<Void> {
  
			@Override
		   protected void decode(ChannelHandlerContext ctx,
								   ByteBuf buf, List<Object> out) {
			   ...
			   // Decode the first message
			   Object firstMessage = ...;
	  
			   // Add the second decoder
			   ctx.pipeline().addLast("second", new SecondDecoder());
	  
			   if (buf.isReadable()) {
				   // 将剩余的数据交给第二个解码器
				   out.add(firstMessage);
				   out.add(buf.readBytes(super.actualReadableBytes()));
			   } else {
				   // Nothing to hand off
				   out.add(firstMessage);
			   }
			   // Remove the first decoder (me)
			   ctx.pipeline().remove(this);
       }
	
		
		