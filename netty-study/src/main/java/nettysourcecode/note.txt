1.NioEventLoopGroup
    构造函数参数可以设定启动的线程数，默认启动的线程数为cpu核心数x2
2.EventLoopGroup
    EventLoopGroup里边包装了多个EventLoop，可以向EventLoopGroup中注册Channel
3.EventExecutorGroup
    EventExecutorGroup里边包装了多个EventExecutor，EventExecutorGroup提供获得EventExecutor的方法，同时也维护自己的生命周期。
4.Executor
    用到了命令模式，提交一个命令给Executor，然后Executor去执行
5.serverBootstrap.group(bossGroup,workerGroup).channel(
                      NioServerSocketChannel.class).childHandler(new MyServerInitializer());
    这行代码执行完，仅仅只是完成了对Bootstrap类的成员属性的赋值工作。
6.netty Future相对于JDK Future的优点？
    a.JDK的Future无法知道任务是什么时候完成的，因此无法知道在什么时候调用Future.get()合适
    而Netty的Future通过观察者模式解决了此问题
    b.netty中的Future的isSuccess方法优于JDK中的isDone方法，因为取消操作也会让isDone返回为true，从而无法得知任务执行完了还是取消了。
7.ChannelFuture
    封装了Channel的Future
                                          +---------------------------+
                                          | Completed successfully    |
                                          +---------------------------+
                                     +---->      isDone() = true      |
     +--------------------------+    |    |   isSuccess() = true      |
     |        Uncompleted       |    |    +===========================+
     +--------------------------+    |    | Completed with failure    |
     |      isDone() = false    |    |    +---------------------------+
     |   isSuccess() = false    |----+---->      isDone() = true      |
     | isCancelled() = false    |    |    |       cause() = non-null  |
     |       cause() = null     |    |    +===========================+
     +--------------------------+    |    | Completed by cancellation |
                                     |    +---------------------------+
                                     +---->      isDone() = true      |
                                          | isCancelled() = true      |
                                          +---------------------------+